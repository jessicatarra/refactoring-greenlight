
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>application: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jessicatarra/greenlight/ms/auth/internal/application/application.go (64.4%)</option>
				
				<option value="file1">github.com/jessicatarra/greenlight/ms/auth/internal/repositories/permission_repository.go (91.3%)</option>
				
				<option value="file2">github.com/jessicatarra/greenlight/ms/auth/internal/repositories/token_repository.go (100.0%)</option>
				
				<option value="file3">github.com/jessicatarra/greenlight/ms/auth/internal/repositories/user_repository.go (68.5%)</option>
				
				<option value="file4">github.com/jessicatarra/greenlight/ms/auth/internal/service/handlers.go (38.4%)</option>
				
				<option value="file5">github.com/jessicatarra/greenlight/ms/auth/internal/service/middleware.go (0.0%)</option>
				
				<option value="file6">github.com/jessicatarra/greenlight/ms/auth/internal/service/routes.go (0.0%)</option>
				
				<option value="file7">github.com/jessicatarra/greenlight/ms/auth/internal/service/service.go (0.0%)</option>
				
				<option value="file8">github.com/jessicatarra/greenlight/ms/auth/internal/service/validation.go (76.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package application

import (
        "github.com/jessicatarra/greenlight/internal/concurrent"
        "github.com/jessicatarra/greenlight/internal/config"
        "github.com/jessicatarra/greenlight/internal/mailer"
        "github.com/jessicatarra/greenlight/ms/auth/internal/domain"
        "github.com/jessicatarra/greenlight/ms/auth/internal/repositories"
        "github.com/pascaldekloe/jwt"
        "strconv"
        "sync"
        "time"
)

type appl struct {
        userRepo       domain.UserRepository
        tokenRepo      domain.TokenRepository
        permissionRepo domain.PermissionRepository
        concurrent     concurrent.Resource
        mailer         mailer.Mailer
        cfg            config.Config
}

func NewAppl(userRepo domain.UserRepository, tokenRepo domain.TokenRepository, permissionRepo domain.PermissionRepository, wg *sync.WaitGroup, cfg config.Config) domain.Appl <span class="cov8" title="1">{
        return &amp;appl{
                userRepo:       userRepo,
                tokenRepo:      tokenRepo,
                permissionRepo: permissionRepo,
                concurrent:     concurrent.NewBackgroundTask(wg),
                mailer:         mailer.New(cfg.Smtp.Host, cfg.Smtp.Port, cfg.Smtp.Username, cfg.Smtp.Password, cfg.Smtp.From),
                cfg:            cfg,
        }
}</span>

func (a *appl) CreateUseCase(input domain.CreateUserRequest, hashedPassword string) (*domain.User, error) <span class="cov8" title="1">{
        user := &amp;domain.User{Name: input.Name, Email: input.Email, Activated: false}

        err := a.userRepo.InsertNewUser(user, hashedPassword)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = a.permissionRepo.AddForUser(user.ID, "movies:read")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">token, err := a.tokenRepo.New(user.ID, 3*24*time.Hour, repositories.ScopeActivation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fn := func() error </span><span class="cov8" title="1">{
                data := map[string]interface{}{
                        "activationToken": token.Plaintext,
                        "userID":          user.ID,
                }
                //print(token.Plaintext)

                err = a.mailer.Send(user.Email, "user_welcome.gohtml", data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">a.concurrent.BackgroundTask(fn)

        return user, err</span>
}

func (a *appl) ActivateUseCase(tokenPlainText string) (*domain.User, error) <span class="cov8" title="1">{
        user, err := a.userRepo.GetForToken(repositories.ScopeActivation, tokenPlainText)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">user.Activated = true

        err = a.userRepo.UpdateUser(user)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = a.tokenRepo.DeleteAllForUser(repositories.ScopeActivation, user.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return user, err</span>
}

func (a *appl) GetByEmailUseCase(email string) (*domain.User, error) <span class="cov8" title="1">{
        existingUser, err := a.userRepo.GetUserByEmail(email)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return existingUser, nil</span>
}

func (a *appl) CreateAuthTokenUseCase(userID int64) ([]byte, error) <span class="cov0" title="0">{
        var claims jwt.Claims
        claims.Subject = strconv.FormatInt(userID, 10)
        claims.Issued = jwt.NewNumericTime(time.Now())
        claims.NotBefore = jwt.NewNumericTime(time.Now())
        claims.Expires = jwt.NewNumericTime(time.Now().Add(24 * time.Hour))
        claims.Issuer = a.cfg.BaseURL
        claims.Audiences = []string{a.cfg.BaseURL}

        jwtBytes, err := claims.HMACSign(jwt.HS256, []byte(a.cfg.Jwt.Secret))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return jwtBytes, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "github.com/jessicatarra/greenlight/ms/auth/internal/domain"
        "github.com/lib/pq"
        "time"
)

type permissionRepository struct {
        db *sql.DB
}

func NewPermissionRepo(db *sql.DB) domain.PermissionRepository <span class="cov8" title="1">{
        return &amp;permissionRepository{db: db}
}</span>

func (p permissionRepository) GetAllForUser(userID int64) (domain.Permissions, error) <span class="cov8" title="1">{
        query := `
        SELECT permissions.code
        FROM permissions
        INNER JOIN users_permissions ON users_permissions.permission_id = permissions.id
        INNER JOIN users ON users_permissions.user_id = users.id
        WHERE users.id = $1`

        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()

        rows, err := p.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var permissions domain.Permissions

        for rows.Next() </span><span class="cov8" title="1">{
                var permission string

                err := rows.Scan(&amp;permission)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">permissions = append(permissions, permission)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return permissions, nil</span>
}

func (p permissionRepository) AddForUser(userID int64, codes ...string) error <span class="cov8" title="1">{
        query := `
        INSERT INTO users_permissions
        SELECT $1, permissions.id FROM permissions WHERE permissions.code = ANY($2)`
        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()

        _, err := p.db.ExecContext(ctx, query, userID, pq.Array(codes))
        return err
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "github.com/jessicatarra/greenlight/ms/auth/internal/domain"
        "time"
)

const (
        ScopeActivation     = "activation"
        ScopeAuthentication = "authentication"
)

type tokenRepository struct {
        db    *sql.DB
        token domain.TokenInterface
}

func NewTokenRepo(db *sql.DB) domain.TokenRepository <span class="cov8" title="1">{
        return &amp;tokenRepository{db: db, token: domain.NewToken()}
}</span>

func (t *tokenRepository) New(userID int64, ttl time.Duration, scope string) (*domain.Token, error) <span class="cov8" title="1">{
        token, err := t.token.GenerateToken(userID, ttl, scope)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = t.Insert(token)
        return token, err</span>
}

func (t *tokenRepository) Insert(token *domain.Token) error <span class="cov8" title="1">{
        query := `
        INSERT INTO tokens (hash, user_id, expiry, scope) 
        VALUES ($1, $2, $3, $4)`

        args := []interface{}{token.Hash, token.UserID, token.Expiry, token.Scope}

        ctx, cancel := context.WithTimeout(context.Background(), defaultTimeout)
        defer cancel()

        _, err := t.db.ExecContext(ctx, query, args...)
        return err
}</span>

func (t *tokenRepository) DeleteAllForUser(scope string, userID int64) error <span class="cov8" title="1">{
        query := `
        DELETE FROM tokens 
        WHERE scope = $1 AND user_id = $2`

        ctx, cancel := context.WithTimeout(context.Background(), defaultTimeout)
        defer cancel()

        _, err := t.db.ExecContext(ctx, query, scope, userID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package repositories

import (
        "context"
        "crypto/sha256"
        "database/sql"
        "errors"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        "github.com/jessicatarra/greenlight/ms/auth/internal/domain"
        _ "github.com/lib/pq"
        "time"
)

const defaultTimeout = 10 * time.Second

type userRepository struct {
        db *sql.DB
}

func NewUserRepo(db *sql.DB) domain.UserRepository <span class="cov8" title="1">{
        return &amp;userRepository{db: db}
}</span>

func (r *userRepository) InsertNewUser(user *domain.User, hashedPassword string) error <span class="cov8" title="1">{
        query := `
        INSERT INTO users (name, email, password_hash, activated) 
        VALUES ($1, $2, $3, $4)
        RETURNING id, created_at, version`

        args := []interface{}{user.Name, user.Email, hashedPassword, user.Activated}

        ctx, cancel := context.WithTimeout(context.Background(), defaultTimeout)
        defer cancel()

        err := r.db.QueryRowContext(ctx, query, args...).Scan(&amp;user.ID, &amp;user.CreatedAt, &amp;user.Version)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case err.Error() == `pq: duplicate key value violates unique constraint "users_email_key"`:<span class="cov0" title="0">
                        return domain.ErrDuplicateEmail</span>
                default:<span class="cov8" title="1">
                        return err</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *userRepository) GetUserByEmail(email string) (*domain.User, error) <span class="cov8" title="1">{
        query := `
        SELECT id, created_at, name, email, password_hash, activated, version
        FROM users
        WHERE email = $1`

        var user domain.User

        ctx, cancel := context.WithTimeout(context.Background(), defaultTimeout)
        defer cancel()

        err := r.db.QueryRowContext(ctx, query, email).Scan(
                &amp;user.ID,
                &amp;user.CreatedAt,
                &amp;user.Name,
                &amp;user.Email,
                &amp;user.HashedPassword,
                &amp;user.Activated,
                &amp;user.Version,
        )

        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return nil, domain.ErrRecordNotFound</span>
                default:<span class="cov8" title="1">
                        return nil, err</span>
                }
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *userRepository) UpdateUser(user *domain.User) error <span class="cov8" title="1">{
        query := `
        UPDATE users SET name = $1, email = $2, password_hash = $3, activated = $4, version = version + 1
        WHERE id = $5 AND version = $6
        RETURNING version`

        args := []interface{}{
                user.Name,
                user.Email,
                user.HashedPassword,
                user.Activated,
                user.ID,
                user.Version,
        }

        ctx, cancel := context.WithTimeout(context.Background(), defaultTimeout)
        defer cancel()

        err := r.db.QueryRowContext(ctx, query, args...).Scan(&amp;user.Version)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case err.Error() == `pq: duplicate key value violates unique constraint "users_email_key"`:<span class="cov0" title="0">
                        return domain.ErrDuplicateEmail</span>
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return domain.ErrEditConflict</span>
                default:<span class="cov8" title="1">
                        return err</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *userRepository) GetForToken(tokenScope string, tokenPlaintext string) (*domain.User, error) <span class="cov0" title="0">{
        tokenHash := sha256.Sum256([]byte(tokenPlaintext))

        query := `
        SELECT users.id, users.created_at, users.name, users.email, users.password_hash, users.activated, users.version
        FROM users
        INNER JOIN tokens
        ON users.id = tokens.user_id
        WHERE tokens.hash = $1
        AND tokens.scope = $2 
        AND tokens.expiry &gt; $3`

        args := []interface{}{tokenHash[:], tokenScope, time.Now()}

        var user domain.User

        ctx, cancel := context.WithTimeout(context.Background(), defaultTimeout)
        defer cancel()

        err := r.db.QueryRowContext(ctx, query, args...).Scan(
                &amp;user.ID,
                &amp;user.CreatedAt,
                &amp;user.Name,
                &amp;user.Email,
                &amp;user.HashedPassword,
                &amp;user.Activated,
                &amp;user.Version,
        )
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return nil, domain.ErrRecordNotFound</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) GetUserById(id int64) (*domain.User, error) <span class="cov8" title="1">{
        query := `
        SELECT id, created_at, name, email, password_hash, activated, version
        FROM users
        WHERE id = $1`

        var user domain.User

        ctx, cancel := context.WithTimeout(context.Background(), defaultTimeout)
        defer cancel()

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;user.ID,
                &amp;user.CreatedAt,
                &amp;user.Name,
                &amp;user.Email,
                &amp;user.HashedPassword,
                &amp;user.Activated,
                &amp;user.Version,
        )

        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                        return nil, domain.ErrRecordNotFound</span>
                default:<span class="cov8" title="1">
                        return nil, err</span>
                }
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package service

import (
        "errors"
        "github.com/jessicatarra/greenlight/internal/database"
        _errors "github.com/jessicatarra/greenlight/internal/errors"
        "github.com/jessicatarra/greenlight/internal/password"
        "github.com/jessicatarra/greenlight/internal/request"
        "github.com/jessicatarra/greenlight/internal/response"
        "github.com/jessicatarra/greenlight/internal/utils/helpers"
        "github.com/jessicatarra/greenlight/ms/auth/internal/domain"
        "github.com/julienschmidt/httprouter"
        "net/http"
)

type envelope map[string]interface{}

type Handlers interface {
        createUser(res http.ResponseWriter, req *http.Request)
        activateUser(res http.ResponseWriter, req *http.Request)
        createAuthenticationToken(res http.ResponseWriter, req *http.Request)
}

type handlers struct {
        appl    domain.Appl
        helpers helpers.Helpers
}

func (s service) Handlers(appl domain.Appl, router *httprouter.Router) <span class="cov0" title="0">{
        res := registerHandlers(appl)

        router.HandlerFunc(http.MethodPost, "/v1/users", res.createUser)
        router.HandlerFunc(http.MethodPut, "/v1/users/activated", res.activateUser)
}</span>

func registerHandlers(appl domain.Appl) Handlers <span class="cov8" title="1">{
        return &amp;handlers{
                appl:    appl,
                helpers: helpers.New(),
        }
}</span>

// @Summary Register User
// @Description Registers a new user.
// @Tags Users
// @Accept json
// @Produce  json
// @Param name body domain.CreateUserRequest true "User registration data"
// @Success 201 {object} domain.User
// @Router /users [post]
func (h *handlers) createUser(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        var input domain.CreateUserRequest

        err := request.DecodeJSON(res, req, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                _errors.BadRequest(res, req, err)
                return
        }</span>

        <span class="cov8" title="1">existingUser, err := h.appl.GetByEmailUseCase(input.Email)
        if err != nil &amp;&amp; err.Error() != domain.ErrRecordNotFound.Error() </span><span class="cov0" title="0">{
                _errors.ServerError(res, req, err)
                return
        }</span>

        <span class="cov8" title="1">ValidateUser(input, existingUser)

        if input.Validator.HasErrors() </span><span class="cov0" title="0">{
                _errors.FailedValidation(res, req, input.Validator)
                return
        }</span>

        <span class="cov8" title="1">hashedPassword, err := password.Hash(input.Password)
        if err != nil </span><span class="cov0" title="0">{
                _errors.ServerError(res, req, err)
                return
        }</span>

        <span class="cov8" title="1">user, err := h.appl.CreateUseCase(input, hashedPassword)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, database.ErrDuplicateEmail):<span class="cov0" title="0">
                        input.Validator.AddError("email a user with this email address already exists")
                        _errors.FailedValidation(res, req, input.Validator)</span>
                default:<span class="cov8" title="1">
                        _errors.ServerError(res, req, err)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">err = response.JSON(res, http.StatusCreated, envelope{"user": user})
        if err != nil </span><span class="cov0" title="0">{
                _errors.ServerError(res, req, err)
        }</span>
}

// @Summary Activate User
// @Description Activates a user account using a token that was previously sent when successfully register a new user
// @Tags Users
// @Accept json
// @Produce  json
// @Param token query string true "Token for user activation"
// @Success 200 {object} domain.User
// @Router /users/activated [put]
func (h *handlers) activateUser(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        var input domain.ActivateUserRequest

        qs := req.URL.Query()

        input.TokenPlaintext = h.helpers.ReadString(qs, "token", "")

        ValidateToken(input)

        if input.Validator.HasErrors() </span><span class="cov0" title="0">{
                _errors.FailedValidation(res, req, input.Validator)
                return
        }</span>

        <span class="cov8" title="1">user, err := h.appl.ActivateUseCase(input.TokenPlaintext)
        if err != nil </span><span class="cov8" title="1">{
                _errors.ServerError(res, req, err)
                return
        }</span>

        <span class="cov8" title="1">err = response.JSON(res, http.StatusCreated, envelope{"user": user})
        if err != nil </span><span class="cov0" title="0">{
                _errors.ServerError(res, req, err)
        }</span>
}

// @Summary Create authentication token
// @Description Creates an authentication token for a user
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body domain.CreateAuthTokenRequest true "Request body"
// @Success 201 {object} domain.Token "Authentication token"
// @Router /tokens/authentication [post]
func (h *handlers) createAuthenticationToken(res http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var input domain.CreateAuthTokenRequest

        err := request.DecodeJSON(res, req, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                _errors.BadRequest(res, req, err)
                return
        }</span>

        <span class="cov0" title="0">existingUser, err := h.appl.GetByEmailUseCase(input.Email)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, domain.ErrRecordNotFound):<span class="cov0" title="0">
                        _errors.InvalidAuthenticationToken(res, req)</span>
                default:<span class="cov0" title="0">
                        _errors.ServerError(res, req, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">ValidateEmailForAuth(input, existingUser)

        if existingUser != nil </span><span class="cov0" title="0">{
                passwordMatches, err := password.Matches(input.Password, existingUser.HashedPassword)
                if err != nil </span><span class="cov0" title="0">{
                        _errors.ServerError(res, req, err)
                        return
                }</span>

                <span class="cov0" title="0">ValidatePasswordForAuth(input, passwordMatches)</span>
        }

        <span class="cov0" title="0">if input.Validator.HasErrors() </span><span class="cov0" title="0">{
                _errors.FailedValidation(res, req, input.Validator)
                return
        }</span>

        <span class="cov0" title="0">jwtBytes, err := h.appl.CreateAuthTokenUseCase(existingUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                _errors.ServerError(res, req, err)
                return
        }</span>

        <span class="cov0" title="0">err = response.JSON(res, http.StatusCreated, envelope{"authentication_token": string(jwtBytes)})
        if err != nil </span><span class="cov0" title="0">{
                _errors.ServerError(res, req, err)
        }</span>

}
</pre>
		
		<pre class="file" id="file5" style="display: none">package service

import (
        "log/slog"
        "net/http"
)

func (s service) logRequestMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                s.logger.Info("request", slog.Group("properties",
                        "request_remote_addr", request.RemoteAddr,
                        "request_proto", request.Proto,
                        "request_method", request.Method,
                        "request_url_request_uri", request.URL.RequestURI()),
                )

                next.ServeHTTP(writer, request)
        }</span>)
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package service

import (
        "github.com/jessicatarra/greenlight/internal/middleware"
        appl "github.com/jessicatarra/greenlight/ms/auth/internal/application"
        repo "github.com/jessicatarra/greenlight/ms/auth/internal/repositories"
        "github.com/julienschmidt/httprouter"
        "net/http"
)

func (s service) Routes() http.Handler <span class="cov0" title="0">{
        router := httprouter.New()

        s.Handlers(appl.NewAppl(repo.NewUserRepo(s.db), repo.NewTokenRepo(s.db), repo.NewPermissionRepo(s.db), s.wg, s.cfg), router)

        m := middleware.NewSharedMiddleware(&amp;s.cfg)

        return m.RecoverPanic(m.RateLimit(m.EnableCORS(s.logRequestMiddleware(router))))
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package service

import (
        "database/sql"
        "github.com/jessicatarra/greenlight/internal/config"
        "github.com/jessicatarra/greenlight/ms/auth/internal/domain"
        "github.com/julienschmidt/httprouter"
        "log/slog"
        "net/http"
        "sync"
)

type Service interface {
        Routes() http.Handler
        logRequestMiddleware(next http.Handler) http.Handler
        Handlers(appl domain.Appl, router *httprouter.Router)
}

type service struct {
        db     *sql.DB
        cfg    config.Config
        wg     *sync.WaitGroup
        logger *slog.Logger
}

func NewService(db *sql.DB, cfg config.Config, wg *sync.WaitGroup, logger *slog.Logger) Service <span class="cov0" title="0">{
        return &amp;service{
                db:     db,
                cfg:    cfg,
                wg:     wg,
                logger: logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package service

import (
        "github.com/jessicatarra/greenlight/internal/password"
        "github.com/jessicatarra/greenlight/internal/utils/validator"
        "github.com/jessicatarra/greenlight/ms/auth/internal/domain"
)

func ValidateUser(input domain.CreateUserRequest, existingUser *domain.User) <span class="cov8" title="1">{
        input.Validator.CheckField(input.Name != "", "name", "must be provided")
        input.Validator.CheckField(len(input.Name) &lt;= 500, "name", "must not be more than 500 bytes long")

        ValidateEmail(input, existingUser)

        ValidatePassword(input)
}</span>

func ValidatePassword(input domain.CreateUserRequest) <span class="cov8" title="1">{
        input.Validator.CheckField(input.Password != "", "Password", "Password is required")
        input.Validator.CheckField(len(input.Password) &gt;= 8, "Password", "Password is too short")
        input.Validator.CheckField(len(input.Password) &lt;= 72, "Password", "Password is too long")
        input.Validator.CheckField(validator.NotIn(input.Password, password.CommonPasswords...), "Password", "Password is too common")
}</span>

func ValidateEmail(input domain.CreateUserRequest, existingUser *domain.User) <span class="cov8" title="1">{
        input.Validator.CheckField(input.Email != "", "Email", "Email is required")
        input.Validator.CheckField(validator.Matches(input.Email, validator.RgxEmail), "Email", "Must be a valid email address")
        input.Validator.CheckField(existingUser == nil, "Email", "Email is already in use")
}</span>

func ValidateToken(input domain.ActivateUserRequest) <span class="cov8" title="1">{
        input.Validator.Check(input.TokenPlaintext != "", "token must be provided")
        input.Validator.Check(len(input.TokenPlaintext) == 26, "token must be 26 bytes long")
}</span>

func ValidateEmailForAuth(input domain.CreateAuthTokenRequest, existingUser *domain.User) <span class="cov0" title="0">{
        input.Validator.CheckField(input.Email != "", "Email", "Email is required")
        input.Validator.CheckField(existingUser != nil, "Email", "Email address could not be found")
}</span>

func ValidatePasswordForAuth(input domain.CreateAuthTokenRequest, passwordMatches bool) <span class="cov0" title="0">{
        input.Validator.CheckField(input.Password != "", "Password", "Password is required")
        input.Validator.CheckField(passwordMatches, "Password", "Password is incorrect")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
